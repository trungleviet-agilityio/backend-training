# Schema vs Application Logic: TV Company Database

## üé¨ Overview

This document defines the division of responsibilities between database schema constraints and application-level logic for the TV Company Database. It ensures proper data integrity while maintaining flexibility for TV series production and broadcasting operations.

## üèóÔ∏è Database Schema Responsibilities

### Primary Key Constraints
- **UUID Primary Keys**: All tables use UUID primary keys for global uniqueness
- **Auto-generation**: Primary keys are automatically generated by the database
- **Referential Integrity**: Foreign keys maintain referential integrity across tables

### Foreign Key Constraints
```sql
-- Core TV series relationships
tv_series.domain_uuid ‚Üí series_domains.uuid
episodes.series_uuid ‚Üí tv_series.uuid
episodes.director_uuid ‚Üí employees.uuid
transmissions.episode_uuid ‚Üí episodes.uuid

-- Employee and role relationships
series_cast.employee_uuid ‚Üí employees.uuid
series_cast.series_uuid ‚Üí tv_series.uuid
series_cast.role_uuid ‚Üí roles.uuid

-- Broadcasting relationships
transmission_channels.transmission_uuid ‚Üí transmissions.uuid
transmission_channels.channel_uuid ‚Üí channels.uuid
```

### Unique Constraints
```sql
-- Domain and series constraints
series_domains.name UNIQUE
tv_series.title UNIQUE within domain (application-level)
channels.name UNIQUE

-- Employee constraints
employees.email UNIQUE

-- Role constraints
roles.name UNIQUE

-- Cast assignment constraints
series_cast(employee_uuid, series_uuid, role_uuid) UNIQUE

-- Broadcasting constraints
transmission_channels(transmission_uuid, channel_uuid) UNIQUE
```

### Check Constraints
```sql
-- Data validation constraints
episodes.duration_minutes > 0 AND episodes.duration_minutes <= 300
transmissions.viewership >= 0
tv_series.end_date > tv_series.start_date (if both provided)
series_cast.end_date > series_cast.start_date (if both provided)
```

### NOT NULL Constraints
```sql
-- Required fields
series_domains.name
tv_series.domain_uuid, tv_series.title
episodes.series_uuid, episodes.director_uuid, episodes.episode_number, episodes.title, episodes.duration_minutes
employees.first_name, employees.last_name, employees.email, employees.employment_date, employees.status
roles.name
series_cast.employee_uuid, series_cast.series_uuid, series_cast.role_uuid
transmissions.episode_uuid, transmissions.transmission_time
channels.name, channels.type
```

## üéØ Application Logic Responsibilities

### 1. **Business Rule Validation**

#### Episode Number Uniqueness
```python
def validate_episode_number(series_uuid, episode_number):
    """Ensure episode number is unique within series"""
    existing = Episode.objects.filter(
        series_uuid=series_uuid,
        episode_number=episode_number,
        deleted=False
    ).exists()
    if existing:
        raise ValidationError("Episode number already exists in this series")
```

#### Director Role Validation
```python
def validate_director_role(employee_uuid):
    """Ensure employee has Director role"""
    has_director_role = SeriesCast.objects.filter(
        employee_uuid=employee_uuid,
        role__name='Director',
        deleted=False
    ).exists()
    if not has_director_role:
        raise ValidationError("Employee must have Director role to direct episodes")
```

#### Character Name Requirements
```python
def validate_character_name(role_name, character_name):
    """Ensure character names are provided for Actor roles"""
    if role_name == 'Actor' and not character_name:
        raise ValidationError("Character name is required for Actor roles")
```

### 2. **Complex Relationship Validation**

#### Multi-Role Employee Support
```python
def assign_employee_to_series(employee_uuid, series_uuid, role_uuid, character_name=None):
    """Assign employee to series with specific role"""
    # Check for existing assignment
    existing = SeriesCast.objects.filter(
        employee_uuid=employee_uuid,
        series_uuid=series_uuid,
        role_uuid=role_uuid,
        deleted=False
    ).exists()

    if existing:
        raise ValidationError("Employee already has this role in this series")

    # Validate character name for Actor roles
    role = Role.objects.get(uuid=role_uuid)
    if role.name == 'Actor' and not character_name:
        raise ValidationError("Character name required for Actor roles")

    # Create assignment
    SeriesCast.objects.create(
        employee_uuid=employee_uuid,
        series_uuid=series_uuid,
        role_uuid=role_uuid,
        character_name=character_name
    )
```

#### Flexible Director Assignment
```python
def assign_director_to_episode(episode_uuid, director_uuid):
    """Assign director to episode with validation"""
    # Validate director has Director role
    validate_director_role(director_uuid)

    # Update episode
    episode = Episode.objects.get(uuid=episode_uuid)
    episode.director_uuid = director_uuid
    episode.save()
```

### 3. **Data Transformation and Enrichment**

#### Employee Status Management
```python
def update_employee_status(employee_uuid, new_status):
    """Update employee status with validation"""
    valid_statuses = ['available', 'busy', 'unavailable']
    if new_status not in valid_statuses:
        raise ValidationError(f"Invalid status. Must be one of: {valid_statuses}")

    employee = Employee.objects.get(uuid=employee_uuid)
    employee.status = new_status
    employee.save()
```

#### Transmission Scheduling
```python
def schedule_transmission(episode_uuid, transmission_time, channel_uuids, viewership=None):
    """Schedule episode transmission on multiple channels"""
    # Create transmission
    transmission = Transmission.objects.create(
        episode_uuid=episode_uuid,
        transmission_time=transmission_time,
        viewership=viewership
    )

    # Assign to channels
    for channel_uuid in channel_uuids:
        TransmissionChannel.objects.create(
            transmission_uuid=transmission.uuid,
            channel_uuid=channel_uuid
        )
```

### 4. **Soft Delete Operations**

#### Logical Deletion
```python
def soft_delete_series(series_uuid):
    """Soft delete series and related data"""
    # Soft delete series
    series = TVSeries.objects.get(uuid=series_uuid)
    series.deleted = True
    series.save()

    # Soft delete episodes
    Episode.objects.filter(series_uuid=series_uuid).update(deleted=True)

    # Soft delete cast assignments
    SeriesCast.objects.filter(series_uuid=series_uuid).update(deleted=True)
```

#### Data Recovery
```python
def restore_series(series_uuid):
    """Restore soft-deleted series"""
    series = TVSeries.objects.get(uuid=series_uuid)
    series.deleted = False
    series.save()

    # Note: Related data restoration requires careful consideration
    # of business rules and data consistency
```

### 5. **Audit and Logging**

#### Change Tracking
```python
def log_data_change(table_name, record_uuid, operation, user_uuid, changes):
    """Log data changes for audit purposes"""
    ValidationLog.objects.create(
        table_name=table_name,
        record_uuid=record_uuid,
        operation=operation,
        user_uuid=user_uuid,
        changes=json.dumps(changes),
        timestamp=timezone.now()
    )
```

#### Business Rule Violation Logging
```python
def log_business_rule_violation(rule_code, details, severity='WARNING'):
    """Log business rule violations"""
    ValidationLog.objects.create(
        table_name='business_rules',
        record_uuid=None,
        operation=f'RULE_VIOLATION_{rule_code}',
        user_uuid=None,
        changes=json.dumps({
            'rule_code': rule_code,
            'details': details,
            'severity': severity
        }),
        timestamp=timezone.now()
    )
```

## üîÑ Integration Points

### Database Triggers
```sql
-- Automatic timestamp updates
CREATE OR REPLACE FUNCTION update_updated_time()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_time = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply to all tables
CREATE TRIGGER update_updated_time_trigger
    BEFORE UPDATE ON table_name
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_time();
```

### Application Hooks
```python
# Django signals for automatic validation
@receiver(pre_save, sender=Episode)
def validate_episode_data(sender, instance, **kwargs):
    """Validate episode data before saving"""
    if instance.pk:  # Update operation
        validate_episode_number(instance.series_uuid, instance.episode_number)
        validate_director_role(instance.director_uuid)
```

## üõ°Ô∏è Error Handling Strategy

### Database Errors
- **Constraint Violations**: Return specific error codes
- **Foreign Key Errors**: Provide user-friendly messages
- **Unique Constraint Errors**: Suggest alternatives

### Application Errors
- **Validation Errors**: Return detailed error messages
- **Business Rule Violations**: Log and notify administrators
- **Data Consistency Errors**: Rollback transactions

### User Experience
- **Clear Error Messages**: Explain what went wrong and how to fix
- **Validation Feedback**: Show errors before form submission
- **Graceful Degradation**: Handle errors without crashing

## üìä Monitoring and Maintenance

### Performance Monitoring
- **Query Performance**: Monitor slow queries and optimize
- **Constraint Performance**: Track constraint validation overhead
- **Application Performance**: Monitor business rule validation time

### Data Quality Monitoring
- **Constraint Violations**: Track frequency and patterns
- **Business Rule Violations**: Monitor compliance rates
- **Data Consistency**: Regular integrity checks

### Maintenance Procedures
- **Index Maintenance**: Regular index optimization
- **Constraint Review**: Periodic constraint effectiveness review
- **Business Rule Updates**: Version control for business rules

---

*This document ensures proper separation of concerns between database schema constraints and application logic, maintaining data integrity while supporting flexible TV series production and broadcasting operations.*
